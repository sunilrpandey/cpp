In case new and new[] functons are not able to allocate memory on heap they call a special function i.e. new-handler. Its a function pointer and you can set your applicationâ€™s function as new-handler. If and only if this new handler function is sucessful in makeing some memory avialable then only it should return other wise it should exit the application else your application will enter a never ending cycle i.e.

#include <cstdlib>
#include <new>
 
 
void out_of_memory()
{
    std::cout<<"Out of Memory :: Handler \n";
 
    // If not able to make memory available then exit else return.
    std::exit (1);
 
}
 
int main()
{
    // Set new handler
    std::set_new_handler(out_of_memory);
    
    // Keep allocating memory dynamically on heap
    // in a cycle till new throws an exception and before 
    // that calls the registered new_handler
    while(true)
    {
        int * ptr = new int[1000];
    }
 
    return 0;
}

- How to check if object was created on heap/stack. set a member variable in new operator
- How  to pass variable argument in a function
int varArgFunction(int numElement, ...) // first argument is mandatory and last element should be elipsis
- create variable argument list 
va_list varList;
initialize list
va_start(varList, numElement)
read the first entry from var arg list
int n = va_arg(varList, int)
How this variable argument stuff works internally
Whenever we pass some argument in a function, all the arguments are stored in a stack and if we know the address of starting point of variable argument then we can easily fetch the next value.
Therefore in va_start we need to pass the argument that jus preceds the variable arguments, so that it can fetch the calculate the starting address of variable arg list.
Then in va_arg we need to pass the type of next argument, so that it can fetch that bytes only to create the argument.
int varArgFunction(int numElements, ...) { // first argument is mandatory and last element should be elipsis
	va_list varList;						//create variable argument list 
	va_start(varList, numElements);		//initialize list
	int sum = 0;
	for (int i = 0; i < numElements; i++) {
		sum += va_arg(varList, int); read the first entry from var arg list
	}
	va_end(varList);
	return sum;
}

-- print sequence of number without for loop or recursion -> use class/struct and static counter variable, increment in constructor, create obj array in main() obj[20]  for printing 20 numbers

deque STL
Deque is a double ended queue container that provides insertion and deletion at both ends i.e. front and back with
high performance unlike vector that provides high performance insertion at end i.e. back only.

Also it provides random access to elements just like a vector. Although one can insert an element in between other elements in dequeue with insert() function, but its performance will not be good just like vector.
https://thispointer.com//what-is-stddeque-and-how-deque-works-internally/
Consider deque as a linked list of vectors i.e. each node of this linked list is a memory block that store elements at contiguous memory location and each of the memory block node is linked with its previous and next memory block node.
